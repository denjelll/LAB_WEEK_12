1. Pola arsitektur MVVM (Model-View-ViewModel) itu sangat penting karena ia memisahkan antara tampilan (UI) dan logika bisnis aplikasi. Dengan pemisahan ini, kalau kamu mau mendesain ulang UI atau memperbarui logika bisnisnya, kamu cukup ubah bagian yang relevan saja tanpa merusak komponen lainnya, sehingga nambah fitur baru atau melakukan testing jadi jauh lebih mudah. Berdasarkan tutorial ini, yang mewakili Model (layer data) adalah file Movie.kt, MovieDao.kt, dan MovieDatabase.kt. Kemudian, View (tampilan UI) diwakili oleh activity_main.xml dan MainActivity.kt. Terakhir, ViewModel yang bertugas mengambil data dari Model untuk diberikan ke View adalah file MovieViewModel.kt.
2. Penggunaan Data Binding dianggap lebih efisien daripada metode biasa karena memungkinkan ViewModel untuk berkomunikasi langsung dengan View tanpa perlu repot menggunakan fungsi manual seperti findViewById. Kamu bisa langsung memanggil atribut (seperti app:list) di dalam elemen RecyclerView di XML, dan atribut tersebut akan langsung mengisi tampilan dengan data dari LiveData atau StateFlow yang ada di ViewModel, membuat kode jadi lebih ringkas.
3. Penerapan Singleton Pattern di bagian kedua sangat krusial karena pola ini menjamin bahwa hanya ada satu instance database yang dibuat untuk seluruh aplikasi. Hal ini penting untuk menjaga validitas data dan mencegah terjadinya Race Conditions (tabrakan proses saat mengakses data). Selain itu, karena membuat instance database baru itu prosesnya berat (expensive), Singleton membantu menjaga performa aplikasi tetap ringan.
4. Repository Pattern yang diterapkan di bagian 2 dan 3 berfungsi sebagai jembatan untuk menyinkronkan data antara layanan web (API) dan database lokal (Room). Pola ini penting agar data di database lokal selalu up-to-date mengikuti server. Keuntungan besarnya adalah user tetap bisa mengakses dan melihat data yang sudah tersimpan (cached) di aplikasi meskipun mereka sedang tidak memiliki koneksi internet.
5. Kita menggunakan WorkManager di bagian 3 karena sebelumnya tidak ada cara otomatis untuk memperbarui database dengan data terbaru saat aplikasi sedang tidak digunakan. Tanpa WorkManager, alternatif lainnya hanyalah memperbarui data saat aplikasi sedang dibuka oleh user. Namun, WorkManager jauh lebih unggul karena bisa dijadwalkan untuk mengambil dan menyimpan data di latar belakang secara berkala, bahkan ketika aplikasi sedang ditutup atau setelah perangkat di-restart.